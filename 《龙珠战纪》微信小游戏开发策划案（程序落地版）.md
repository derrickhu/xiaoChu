# 《龙珠战纪》微信小游戏开发策划案（程序落地版）

# 一、项目基础信息（必看）

## 1.1 核心定位

竖屏轻量转珠消除+回合制RPG微信小游戏，复刻《智龙迷城》核心玩法（转珠Combo+属性克制+轻量化养成），目标用户18-35岁休闲益智玩家；个人开发者可落地，无服务器依赖，核心体验不缩水，预留视觉效果优化接口。

## 1.2 技术栈（固定，不可更改）

|模块|技术方案|具体要求|
|---|---|---|
|开发工具|微信开发者工具|使用最新稳定版，调试模式默认开启，兼容微信小游戏所有基础API|
|渲染引擎|Canvas 2D + JavaScript|禁止使用第三方引擎（如Cocos、Unity），禁止使用WebGL（原因见3.2）|
|数据存储|微信本地缓存API|仅使用wx.setStorageSync/wx.getStorageSync，存储角色、队伍、关卡进度等数据|
|音效|微信小游戏音频API|支持MP3格式，单文件体积≤1MB，总音效体积≤5MB|
|动画|requestAnimationFrame|原生实现，不引入第三方动画库，帧率稳定在30-60FPS|
## 1.3 开发优先级（严格遵循）

- P0（必做，核心可玩）：转珠消除、战斗流程、基础角色/关卡、本地数据存储

- P1（必做，体验完整）：队伍编辑、主动技能、战斗结算、新手引导

- P2（可选，效果优化）：粒子特效、攻击光效、Combo动效

- P3（可选，后期迭代）：社交分享、本地排行榜、角色升级

## 1.4 性能与兼容性要求（必须达标）

- 帧率：主流手机（安卓8.0+、iOS10.0+）帧率≥30FPS，无卡顿、无掉帧

- 内存：运行时内存占用≤100MB，无内存泄漏

- 适配：竖屏16:9，支持3.5-6.7英寸手机，界面元素自适应缩放

- 启动速度：游戏启动时间≤3秒，关卡加载时间≤1秒

# 二、核心玩法模块（P0/P1优先级，程序必实现）

## 2.1 转珠消除系统（核心，P0）

### 2.1.1 棋盘基础规则（固定）

- 棋盘规格：固定6列×5行，共30个宝珠位置，无缩放、无变形

- 宝珠属性：6种，对应配色+纹理（不可更改）
       

    - 火：红色（red，纹理路径：images/bead/fire.png）

    - 水：蓝色（blue，纹理路径：images/bead/water.png）

    - 木：绿色（green，纹理路径：images/bead/wood.png）

    - 光：黄色（yellow，纹理路径：images/bead/light.png）

    - 暗：紫色（purple，纹理路径：images/bead/dark.png）

    - 心：粉色（pink，纹理路径：images/bead/heart.png）

- 宝珠尺寸：单个宝珠直径=屏幕宽度/7（自适应，确保6列均匀分布）

### 2.1.2 宝珠生成与填充逻辑

1. 初始生成：游戏启动/关卡开始时，随机生成30个宝珠，确保无初始3连消除（横向/纵向均无）；若生成后存在3连，自动重新生成

2. 消除后填充：消除完成后，上方宝珠垂直下落，填充空白位置；空白位置从顶部随机生成新宝珠，生成规则同初始生成（无3连）

3. 填充动画：下落速度=宝珠直径/0.3秒（匀速下落），新宝珠从顶部淡入（透明度0→1，时长0.2秒）

### 2.1.3 转珠交互逻辑（程序严格对照）

1. 触摸开始（touchstart）：
        

    - 获取触摸坐标（e.touches[0].clientX/e.touches[0].clientY）

    - 判断触摸位置是否在宝珠范围内，若在，标记该宝珠为选中状态（selectedBead），设置isDragging=true

    - 选中反馈：选中的宝珠缩放至1.1倍，边框高亮（颜色#fff，宽度2px）

2. 触摸移动（touchmove）：
        

    - 若isDragging=false，不执行任何操作

    - 实时获取触摸坐标，判断滑动方向（上下左右），仅允许相邻宝珠交换（不可跨格交换）

    - 滑动过程中，选中宝珠与目标宝珠实时交换位置，实时绘制，无延迟

3. 触摸结束（touchend）：
        

    - 设置isDragging=false，取消宝珠选中状态（缩放恢复1.0倍，边框消失）

    - 调用消除检测方法（checkEliminate），判断当前棋盘是否有可消除宝珠

    - 若有可消除宝珠，执行消除动画+结算；若无，将交换的宝珠恢复至原位置（动画时长0.2秒）

### 2.1.4 消除判定与Combo计算

1. 消除判定：
        

    - 遍历整个棋盘，检测横向/纵向同色宝珠≥3个的连续组合，标记为可消除组

    - 判定顺序：先横向后纵向，从左到右、从下到上

    - 不可消除场景：斜向连接、同色宝珠＜3个、跨列/跨行不连续

2. Combo计算：
        

    - Combo数=单次消除的可消除组数（例：同时消除2组火珠+1组水珠，Combo=3）

    - Combo数显示：消除后，在棋盘中央弹出Combo数字（字体大小=宝珠直径，颜色#ff0000，加粗），数字从1递增，停留1秒后消失

    - Combo倍率：1.2^(Combo数-1)（例：Combo=1→1.0倍，Combo=2→1.2倍，Combo=3→1.44倍，以此类推）

### 2.1.5 消除动画（必做基础版）

- 动画时长：0.5秒，匀速执行

- 动画效果：可消除宝珠透明度从1→0，同时缩放从1.0→0.8，最终消失

- 执行顺序：先播放消除动画，动画结束后，再执行宝珠下落填充

## 2.2 回合制战斗系统（核心，P0）

### 2.2.1 战斗流程（固定顺序，不可更改）

1. 战斗启动：进入关卡后，加载我方队伍数据、敌方数据，绘制战斗界面，进入玩家回合

2. 玩家回合：
        

    - 转珠阶段：执行2.1节转珠逻辑，玩家完成转珠操作

    - 结算阶段：
                

        1. 计算Combo数，获取Combo倍率

        2. 计算伤害：遍历我方队伍，按角色属性匹配消除的宝珠，单角色伤害=角色atk × Combo倍率 × 队长技能倍率（无队长技能则×1.0）

        3. 计算回血：总回血=心珠消除数 × 1000（固定值，不可更改），若回血后我方HP超过最大HP，按最大HP计算

        4. 播放反馈：伤害数字弹窗（对应属性颜色，从敌方头像位置向上飘移，时长1秒）、我方HP变化动画（回血绿色渐变，掉血红色渐变）

        5. 扣除敌方HP：总伤害汇总后，从敌方HP中扣除，播放敌方HP减少动画

    - 胜负判定1：若敌方HP≤0，战斗胜利，进入结算界面；若未结束，进入敌方回合

3. 敌方回合：
        

    - 敌方行动：按预设AI（triggerTurn字段）执行攻击，对我方造成伤害（敌方atk固定，无Combo倍率）

    - 反馈：播放敌方攻击动画（简化版，无需复杂特效）、我方HP减少动画、伤害数字弹窗

    - 胜负判定2：若我方HP≤0，战斗失败，弹出失败弹窗（重新挑战/返回关卡）；若未结束，回到玩家回合

### 2.2.2 数值规则（固定公式，不可更改）

- 伤害计算公式：单角色伤害 = 角色baseAtk × 1.2^(Combo数-1) × 队长技能effectRate

- 总伤害 = 所有角色伤害之和（同属性角色伤害叠加，不同属性分别计算后汇总）

- 回血计算公式：总回血 = 心珠消除数量 × 1000

- 属性克制规则：火→木→水→火（克制方伤害×1.5），光↔暗（互克，伤害×1.5），无克制关系则×1.0

- HP计算：我方总HP=所有队伍角色baseHp之和；敌方HP=单只怪物hp（单关卡仅1只敌方，后期可扩展）

## 2.3 角色与队伍系统（P1，必做）

### 2.3.1 角色数据结构（JSON，固定格式，程序直接解析）

```json
{
  "charId": 1001, // 角色唯一ID，递增，不可重复
  "charName": "火焰龙", // 角色名称
  "attr": "火", // 属性：火/水/木/光/暗/心（严格对应2.1.1）
  "baseAtk": 1500, // 基础攻击，固定值
  "baseHp": 8000, // 基础HP，固定值
  "activeSkill": { // 主动技能，无技能则为null
    "skillId": 2001,
    "skillName": "火焰冲击",
    "skillDesc": "将所有心珠转为火珠",
    "cd": 6, // 冷却回合数，每回合结束后cd-1
    "currentCd": 0, // 当前冷却，0可释放，释放后重置为cd值
    "effectType": "beadConvert", // 特效类型，预留扩展
    "param": { // 技能参数，珠型转换专用
      "fromBead": "心", // 转换前宝珠类型
      "toBead": "火" // 转换后宝珠类型
    }
  },
  "leaderSkill": { // 队长技能，无技能则为null
    "skillId": 3001,
    "skillName": "炎之觉醒",
    "skillDesc": "火属性角色攻击×3",
    "effectRate": 3, // 倍率
    "attrLimit": "火" // 生效属性，无限制则为null
  },
  "iconUrl": "images/char/1001.png", // 角色头像路径，必须存在
  "attackEffectUrl": "images/effect/fire_attack.png" // 攻击特效路径，P2阶段实现
}
```

### 2.3.2 队伍编辑规则

- 队伍配置：固定6个槽位，2个队长槽（主队长、友队长），4个队员槽

- 队长技能生效：主队长技能始终生效；友队长技能P3阶段实现，当前暂不生效

- 编辑交互：
        

    - 点击左侧角色列表，将角色添加到右侧空槽位

    - 点击右侧槽位中的角色，可移除该角色（返回角色列表）

    - 不可重复添加同一角色（charId相同则禁止添加）

- 数据存储：队伍数据存储在本地缓存，key为"teamData"，格式为JSON数组（6个元素，空槽位为null）

### 2.3.3 主动技能释放逻辑

1. CD计算：每回合结束后（玩家回合→敌方回合、敌方回合→玩家回合），所有角色activeSkill.currentCd -= 1（cd≤0时不变化）

2. 释放条件：activeSkill.currentCd == 0，且在玩家回合（转珠阶段可释放，结算阶段不可释放）

3. 释放操作：点击角色头像，触发技能释放，执行技能效果（如珠型转换），然后将currentCd重置为cd值

4. 技能效果执行：以“珠型转换”为例，将棋盘所有fromBead类型宝珠，转为toBead类型，实时重绘棋盘，无动画（P2阶段可添加转换动画）

## 2.4 关卡与结算系统（P1，必做）

### 2.4.1 关卡数据结构（JSON，固定格式，程序直接解析）

```json
{
  "levelId": 1, // 关卡唯一ID，递增
  "levelName": "森林试炼", // 关卡名称
  "enemy": { // 单关卡仅1只敌方，后期可扩展多只
    "enemyId": 2001,
    "enemyName": "小火龙",
    "attr": "火",
    "hp": 50000, // 敌方初始HP
    "atk": 3000, // 敌方攻击
    "skill": { // 敌方技能，无技能则为null
      "skillName": "火焰吐息",
      "skillDesc": "对我方造成火属性伤害",
      "triggerTurn": 3 // 第3回合触发，每3回合触发一次
    },
    "iconUrl": "images/enemy/2001.png"
  },
  "reward": { // 战斗胜利奖励
    "gold": 1000, // 金币，用于角色升级（P3阶段）
    "charId": 1002 // 解锁角色ID，无则为null
  },
  "unlockCondition": { // 关卡解锁条件
    "preLevelId": 0 // 前置关卡ID，0表示无前置（第一关）
  }
}
```

### 2.4.2 关卡流程

1. 关卡选择界面：加载所有关卡数据，按levelId排序，已解锁关卡正常显示，未解锁关卡置灰（不可点击）

2. 战斗准备：点击已解锁关卡，进入准备界面，显示敌方信息、我方队伍，提供“开始战斗”“编辑队伍”按钮

3. 战斗过程：执行2.2节战斗流程

4. 战斗结算：
       

    - 胜利结算：弹出胜利弹窗，显示获得的奖励，提供“下一关”“返回关卡”按钮；同时更新本地缓存（已通关关卡、解锁角色、金币）

    - 失败结算：弹出失败弹窗，显示“战斗失败”，提供“重新挑战”“返回关卡”按钮；不更新任何数据

### 2.4.3 数据存储规则（固定key，不可更改）

- 已通关关卡：key="passedLevels"，值为JSON数组（存储levelId，如[1,2,3]）

- 当前关卡：key="currentLevel"，值为当前解锁的最高关卡levelId（默认1）

- 解锁角色：key="unlockedChars"，值为JSON数组（存储charId，如[1001,1002]）

- 金币：key="gold"，值为数字（默认0，胜利后累加）

- 队伍数据：key="teamData"，值为JSON数组（6个元素，空槽位为null）

## 2.5 新手引导（P1，必做）

- 触发条件：首次启动游戏（本地缓存无"firstEnter"字段），触发新手引导

- 引导流程（固定步骤，不可更改）：
        

    1. 引导1：提示“滑动宝珠，连成3个及以上即可消除”，引导玩家滑动指定2个相邻宝珠，完成首次消除

    2. 引导2：提示“消除宝珠可触发攻击”，自动完成一次消除，展示伤害结算

    3. 引导3：提示“点击角色头像释放技能”，引导玩家点击CD=0的角色，释放主动技能

    4. 引导4：提示“通关可获得奖励”，引导玩家完成第一关，查看胜利结算

- 引导结束：完成所有步骤后，设置localStorage.setItem("firstEnter", "true")，后续启动游戏不再触发

# 三、技术实现细节（程序重点关注）

## 3.1 核心代码伪代码（可直接复用）

### 3.1.1 转珠核心逻辑伪代码

```javascript
// 宝珠棋盘类（Canvas 2D）
class BeadBoard {
  constructor() {
    this.cols = 6; // 固定6列
    this.rows = 5; // 固定5行
    this.beadSize = wx.getSystemInfoSync().windowWidth / 7; // 宝珠尺寸
    this.canvas = wx.createCanvas();
    this.ctx = this.canvas.getContext('2d');
    this.beads = []; // 宝珠数据数组（rows×cols）
    this.isDragging = false;
    this.selectedBead = null; // {row: 0, col: 0, attr: "火"}
    this.initBoard(); // 初始化棋盘
    this.bindTouchEvent(); // 绑定触摸事件
  }

  // 初始化棋盘（生成无初始3连的宝珠）
  initBoard() {
    do {
      this.beads = [];
      for (let i = 0; i < this.rows; i++) {
        const row = [];
        for (let j = 0; j < this.cols; j++) {
          const attr = ["火", "水", "木", "光", "暗", "心"][Math.floor(Math.random() * 6)];
          row.push({ attr, x: j * this.beadSize, y: i * this.beadSize, scale: 1.0, alpha: 1.0 });
        }
        this.beads.push(row);
      }
    } while (this.checkEliminate().length > 0); // 确保无初始3连
    this.render();
  }

  // 绑定触摸事件
  bindTouchEvent() {
    this.canvas.addEventListener('touchstart', (e) => {
      const { clientX, clientY } = e.touches[0];
      const col = Math.floor(clientX / this.beadSize);
      const row = Math.floor(clientY / this.beadSize);
      if (row >= 0 && row < this.rows && col >= 0 && col < this.cols) {
        this.isDragging = true;
        this.selectedBead = { row, col };
        this.beads[row][col].scale = 1.1; // 选中缩放
        this.render();
      }
    });

    this.canvas.addEventListener('touchmove', (e) => {
      if (!this.isDragging) return;
      const { clientX, clientY } = e.touches[0];
      const targetCol = Math.floor(clientX / this.beadSize);
      const targetRow = Math.floor(clientY / this.beadSize);
      // 仅允许相邻宝珠交换
      if (Math.abs(targetRow - this.selectedBead.row) + Math.abs(targetCol - this.selectedBead.col) === 1) {
        // 交换宝珠
        [this.beads[this.selectedBead.row][this.selectedBead.col], this.beads[targetRow][targetCol]] = 
        [this.beads[targetRow][targetCol], this.beads[this.selectedBead.row][this.selectedBead.col]];
        this.render();
      }
    });

    this.canvas.addEventListener('touchend', () => {
      this.isDragging = false;
      const eliminateGroups = this.checkEliminate();
      if (eliminateGroups.length > 0) {
        this.executeEliminate(eliminateGroups); // 执行消除
      } else {
        // 无消除，恢复宝珠位置（简化动画）
        setTimeout(() => {
          [this.beads[this.selectedBead.row][this.selectedBead.col], this.beads[targetRow][targetCol]] = 
          [this.beads[targetRow][targetCol], this.beads[this.selectedBead.row][this.selectedBead.col]];
          this.beads[this.selectedBead.row][this.selectedBead.col].scale = 1.0;
          this.render();
        }, 200);
      }
    });
  }

  // 检测可消除宝珠
  checkEliminate() {
    const eliminateGroups = [];
    // 横向检测
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.cols - 2; j++) {
        const attr = this.beads[i][j].attr;
        if (attr === this.beads[i][j+1].attr && attr === this.beads[i][j+2].attr) {
          eliminateGroups.push([{row: i, col: j}, {row: i, col: j+1}, {row: i, col: j+2}]);
        }
      }
    }
    // 纵向检测
    for (let j = 0; j < this.cols; j++) {
      for (let i = 0; i < this.rows - 2; i++) {
        const attr = this.beads[i][j].attr;
        if (attr === this.beads[i+1][j].attr && attr === this.beads[i+2][j].attr) {
          eliminateGroups.push([{row: i, col: j}, {row: i+1, col: j}, {row: i+2, col: j}]);
        }
      }
    }
    return eliminateGroups;
  }

  // 执行消除+填充
  executeEliminate(eliminateGroups) {
    // 1. 标记消除宝珠，播放消除动画
    eliminateGroups.forEach(group => {
      group.forEach(({row, col}) => {
        this.beads[row][col].alpha = 0;
        this.beads[row][col].scale = 0.8;
      });
    });
    this.render();

    // 2. 动画结束后，下落填充
    setTimeout(() => {
      this.fillBead();
      this.render();
    }, 500);
  }

  // 宝珠下落填充
  fillBead() {
    // 纵向下落（从下到上）
    for (let j = 0; j < this.cols; j++) {
      const newCol = [];
      // 收集非消除的宝珠
      for (let i = 0; i < this.rows; i++) {
        if (this.beads[i][j].alpha !== 0) {
          newCol.push(this.beads[i][j]);
        }
      }
      // 补充新宝珠（无初始3连）
      while (newCol.length< this.rows) {
        let attr;
        do {
          attr = ["火", "水", "木", "光", "暗", "心"][Math.floor(Math.random() * 6)];
        } while (newCol.length >= 2 && newCol[newCol.length-1].attr === attr && newCol[newCol.length-2].attr === attr);
        newCol.unshift({ attr, x: j * this.beadSize, y: -this.beadSize, scale: 1.0, alpha: 1.0 });
      }
      // 更新列数据
      for (let i = 0; i < this.rows; i++) {
        this.beads[i][j] = newCol[i];
        this.beads[i][j].y = i * this.beadSize; // 重置y坐标（下落动画后续优化）
      }
    }
  }

  // 渲染棋盘
  render() {
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    // 绘制宝珠
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.cols; j++) {
        const bead = this.beads[i][j];
        this.ctx.save();
        this.ctx.globalAlpha = bead.alpha;
        // 绘制宝珠纹理（替换为实际图片路径）
        const img = wx.createImage();
        img.src = `images/bead/${bead.attr}.png`;
        this.ctx.drawImage(
          img,
          bead.x + (this.beadSize - this.beadSize * bead.scale) / 2,
          bead.y + (this.beadSize - this.beadSize * bead.scale) / 2,
          this.beadSize * bead.scale,
          this.beadSize * bead.scale
        );
        this.ctx.restore();
      }
    }
  }
}
```

### 3.1.2 战斗结算核心逻辑伪代码

```javascript
// 战斗结算类
class BattleCalculator {
  constructor(teamData, enemyData) {
    this.team = teamData; // 我方队伍数据（JSON数组）
    this.enemy = enemyData; // 敌方数据
    this.combo = 0; // 当前Combo数
    this.totalDamage = 0; // 总伤害
    this.totalHeal = 0; // 总回血
  }

  // 计算结算数据
  calculate(eliminateGroups, heartCount) {
    // 1. 计算Combo数
    this.combo = eliminateGroups.length;
    // 2. 计算总伤害
    this.calcTotalDamage(eliminateGroups);
    // 3. 计算总回血
    this.totalHeal = heartCount * 1000;
    // 4. 扣除敌方HP
    this.enemy.hp = Math.max(0, this.enemy.hp - this.totalDamage);
    // 5. 恢复我方HP
    this.healTeam();
    // 返回结算结果
    return {
      combo: this.combo,
      totalDamage: this.totalDamage,
      totalHeal: this.totalHeal,
      enemyHp: this.enemy.hp,
      teamHp: this.getTeamTotalHp()
    };
  }

  // 计算总伤害
  calcTotalDamage(eliminateGroups) {
    this.totalDamage = 0;
    // 获取队长技能倍率
    const leaderRate = this.getLeaderSkillRate();
    // 遍历所有消除组，计算对应属性伤害
    eliminateGroups.forEach(group => {
      const attr = group[0].attr; // 消除组属性
      // 遍历我方队伍，匹配属性计算伤害
      this.team.forEach(char => {
        if (char && char.attr === attr) {
          const damage = char.baseAtk * Math.pow(1.2, this.combo - 1) * leaderRate;
          this.totalDamage += Math.floor(damage);
        }
      });
    });
    // 应用属性克制
    this.applyAttr克制();
  }

  // 获取队长技能倍率
  getLeaderSkillRate() {
    const leader = this.team[0]; // 主队长（第一个槽位）
    if (!leader || !leader.leaderSkill) return 1.0;
    // 按队长技能生效条件计算倍率
    if (leader.leaderSkill.attrLimit) {
      // 仅指定属性生效，取队伍中该属性角色的最大倍率（此处简化为直接取倍率）
      return leader.leaderSkill.effectRate;
    } else {
      // 全属性生效
      return leader.leaderSkill.effectRate;
    }
  }

  // 应用属性克制
  applyAttr克制() {
    const克制Map = {
      "火": "木",
      "木": "水",
      "水": "火",
      "光": "暗",
      "暗": "光"
    };
    if (克制Map[this.enemy.attr] === this.getTeamMainAttr()) {
      this.totalDamage = Math.floor(this.totalDamage * 1.5);
    }
  }

  // 获取队伍主属性（出现次数最多的属性）
  getTeamMainAttr() {
    const attrCount = {};
    this.team.forEach(char => {
      if (char) {
        attrCount[char.attr] = (attrCount[char.attr] || 0) + 1;
      }
    });
    let mainAttr = "火";
    let maxCount = 0;
    for (const attr in attrCount) {
      if (attrCount[attr] > maxCount) {
        maxCount = attrCount[attr];
        mainAttr = attr;
      }
    }
    return mainAttr;
  }

  // 恢复我方队伍HP
  healTeam() {
    const teamTotalHp = this.getTeamTotalHp();
    const newTeamHp = Math.min(teamTotalHp + this.totalHeal, this.getTeamMaxHp());
    // 此处简化为平均分配回血，可后续优化
    const healPerChar = Math.floor((newTeamHp - teamTotalHp) / this.getTeamAliveCount());
    this.team.forEach(char => {
      if (char) {
        char.currentHp = Math.min(char.baseHp, (char.currentHp || char.baseHp) + healPerChar);
      }
    });
  }

  // 获取队伍当前总HP
  getTeamTotalHp() {
    return this.team.reduce((sum, char) => {
      return sum + (char ? (char.currentHp || char.baseHp) : 0);
    }, 0);
  }

  // 获取队伍最大HP
  getTeamMaxHp() {
    return this.team.reduce((sum, char) => {
      return sum + (char ? char.baseHp : 0);
    }, 0);
  }

  // 获取队伍存活角色数（currentHp > 0）
  getTeamAliveCount() {
    return this.team.filter(char => char && (char.currentHp || char.baseHp) > 0).length;
  }
}
```

## 3.2 为什么不使用WebGL？（程序无需纠结，按此执行）

- 开发成本问题：WebGL需掌握GLSL着色器、矩阵变换等底层知识，个人开发者需额外投入1-2周学习，而Canvas 2D可直接上手，调试高效

- 性能无需担忧：本游戏核心是6×5棋盘渲染，Canvas 2D的渲染性能完全满足需求，WebGL的高性能优势无法体现，反而增加开发复杂度

- 效果可优化：后期可通过“精灵图帧动画+轻量级粒子库（particles.js，≤50KB）”，实现接近WebGL的视觉效果，无需切换技术栈

- 兼容性风险：微信小游戏中WebGL的上下文管理、纹理加载易出机型适配问题，个人排查难度高，Canvas 2D兼容性100%

## 3.3 性能优化要点（必须实现）

1. 纹理预加载：游戏启动时，预加载所有宝珠、角色、敌方纹理，存储在内存中，避免运行时加载导致卡顿（使用wx.getImageInfo预加载）

2. 局部重绘：仅重绘变化的区域（如转珠时仅重绘交换的2个宝珠，消除时仅重绘消除组），而非整个画布

3. 动画节流：使用requestAnimationFrame控制动画帧率，避免过度绘制，确保帧率稳定在30-60FPS

4. 数据缓存：缓存已计算的Combo倍率、队长技能倍率，避免重复计算；缓存已加载的纹理，避免重复创建图片对象

5. 素材压缩：所有图片素材压缩至≤50KB/张，音效压缩至≤1MB/个，总素材体积≤10MB

## 3.4 后期效果优化方案（P2阶段，可选）

- 粒子特效：引入particles.js，在宝珠消除时，生成同属性颜色的粒子飞溅效果（粒子数量≤50个/次，避免卡顿）

- 攻击光效：角色攻击时，绘制属性对应的光效（如火球、水流），使用精灵图帧动画实现

- Combo动效：Combo≥5时，添加全屏闪光提示，Combo数字添加缩放+渐变动画

- 珠型转换动画：主动技能触发珠型转换时，添加渐变动画（透明度0→1，时长0.3秒）

# 四、界面与交互规范（程序严格对照）

## 4.1 整体界面布局（竖屏16:9，自适应）

|界面区域|占比|核心内容|交互要求|
|---|---|---|---|
|顶部区域|20%|敌方头像（左）、敌方HP条（中）、回合数（右）|敌方HP减少时，播放红色渐变动画；回合数切换时，数字闪烁1次|
|中部区域|30%|我方6个角色头像（横向排列）、每个角色的HP条、技能CD倒计时|角色HP变化时播放渐变动画；CD倒计时实时更新，CD=0时头像高亮；点击头像释放技能|
|底部区域|50%|6×5转珠棋盘（居中显示）|触摸滑动转珠，实时反馈；消除、填充动画流畅，无卡顿|
## 4.2 关键界面细节

### 4.2.1 战斗界面（核心）

- 敌方HP条：宽度=屏幕宽度×0.4，高度=10px，背景色#666，进度色#ff0000，HP变化时平滑过渡

- 角色头像：直径=屏幕宽度/8，横向均匀分布，头像下方显示HP条（宽度=头像直径×0.8，高度=5px）

- 技能CD倒计时：角色头像右上角显示CD数字（字体大小=头像直径/4，颜色#fff，背景色#000，圆角4px），CD>0时显示，CD=0时隐藏

- 回合数：右上角显示“回合：X”（字体大小=20px，颜色#333，加粗）

### 4.2.2 关卡选择界面

- 标题：顶部居中显示“关卡选择”（字体大小=28px，颜色#333，加粗）

- 关卡布局：关卡图标（直径=屏幕宽度/5），每行3个，均匀分布，图标显示关卡号+关卡名称

- 状态区分：已通关关卡图标高亮，未解锁关卡图标置灰（透明度50%），不可点击

- 返回按钮：左上角显示“返回”按钮（字体大小=22px，颜色#333），点击返回主界面

### 4.2.3 队伍编辑界面

- 布局：左侧角色列表（宽度=屏幕宽度×0.4），右侧队伍槽位（宽度=屏幕宽度×0.6）

- 角色列表：每个角色显示头像+名称+属性，纵向排列，可滑动，已解锁角色正常显示，未解锁角色置灰

- 队伍槽位：6个槽位（2个队长槽+4个队员槽），队长槽标注“队长”字样，空槽位显示“+”图标

- 确认按钮：底部居中显示“确认”按钮（宽度=屏幕宽度×0.5，高度=40px），点击保存队伍配置

## 4.3 交互规范（不可更改）

- 点击反馈：所有可点击元素（按钮、角色、关卡），点击时缩放至0.95倍，松开恢复1.0倍，反馈时长0.1秒

- 弹窗规范：所有弹窗（胜利、失败、提示）居中显示，背景半透明（rgba(0,0,0,0.5)），弹窗自身为白色圆角矩形（圆角8px），弹窗内按钮横向排列

- 滑动规范：角色列表、关卡列表滑动时，有惯性滑动效果，滑动速度与触摸速度成正比，无卡顿

- 加载提示：游戏启动、关卡加载时，显示加载动画（简单旋转图标），加载完成后自动消失，加载时间≤1秒

# 五、开发计划与验收标准

## 5.1 开发阶段划分（严格按周期执行）

|阶段|周期|核心交付物|验收标准|
|---|---|---|---|
|阶段1：核心玩法（P0）|3-5天|转珠交互、消除判定、基础战斗流程、本地数据存储|转珠流畅，消除准确，战斗流程正常，数据存储/读取无误|
|阶段2：功能完善（P1）|2-3天|队伍编辑、主动技能、战斗结算、新手引导|队伍编辑正常，技能释放无误，结算准确，新手引导流畅|
|阶段3：性能优化（必做）|1天|纹理预加载、局部重绘、动画节流|帧率≥30FPS，无卡顿，内存占用≤100MB|
|阶段4：效果优化（P2，可选）|2-3天|粒子特效、攻击光效、Combo动效|特效流畅，不影响性能，视觉效果符合要求|
|阶段5：上线准备|1天|合规性优化、审核材料准备、版本打包|素材无版权问题，隐私政策完整，可正常提交审核|
## 5.2 上线前验收标准（必须全部达标）

1. 核心功能：转珠消除准确，战斗流程无bug，队伍编辑、技能释放正常，关卡进度存储无误

2. 性能：主流手机帧率≥30FPS，启动时间≤3秒，关卡加载≤1秒，无卡顿、无闪退、无内存泄漏

3. 兼容性：适配安卓8.0+、iOS10.0+，不同尺寸手机界面无变形、无遮挡

4. 交互：所有按钮、触摸操作有效，反馈及时
> （注：文档部分内容可能由 AI 生成）